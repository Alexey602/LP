# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Плешков А.О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |      3    (возм испр на 4)      |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение
В результате выполнения курсовой работы я получу навыки работы с новым языком – Prolog. В виде вспомогательного языка вспомню Python, изучу работу с файлами. Расширю свой кругозор в сфере “кто кому приходится”.Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Дерево было создано на сайте Myheritage.com, оно удобно тем, что приглашенные по почте люди могут добавлять новых людей. Единственный минус – в ограничении по количеству человек в бесплатной версии, но если не заморачиваться над этим глобально, то всем подойдет. В моем дереве на данный момент 27 человек.

## Конвертация родословного дерева

Для конвертации родословного дерева мною был выбран язык программирования Python (императивный). Дело в том, что язык сам по себе интуитивно понятный, с мощными циклами, и в нем нет массивов, вместо этого список списков – это дает возможность создавать любой подсписок разной длины, при необходимости.

Основная идея программы в том, чтобы создать “таблицу”, в которой в первый столбец будем заносить имена людей из дерева, во второй столбец и третий столбец FAMS – индекс у человека, указывающий в какой семье он является родителем. Два столбца под FAMS выделено для тех людей, которые являются родителем в двух семьях, подразумевается, что никто не может быть родителем больше, чем в двух семьях. Последний, четвертый столбец выделен для FAMC – индекс у человек, указывающий в какой семье он является ребенком.

Разделение по пробелу:

s = list(s.split())

Создание списка из списков с 4-мя элементами, количество = количеству людей:

A = s.count("NAME")

B = []

for i in range(A):

    B.append([0] * 4)

Далее пробегаемся по нашему открытому файлу и ищем совпадения на NAME, SEX, FAMS, FAMS, INDI:

for i in range(len(s)):

    if s[i] == "NAME":

        k = 0

        if s[i+2]=="//":

            M = s[i+1]

        else:

            s[i+2] = s[i+2].replace("/", "")

            M = s[i+1] + "_" + s[i+2]

    if s[i] == "SEX" and s[i+1] == "M":

        p=1

        j=j+1

        B[j][0] = M

        print("sex(",B[j][0],", m).",sep='',file=output)

    if s[i] == "FAMS" and k == 0 and p==1:

        B[j][1] = s[i+1]

        k = k + 1

    elif s[i] == "FAMS" and p==1:

        B[j][2] = s[i+1]

    if s[i] == "FAMC" and p==1:

        B[j][3] = s[i+1]

    if s[i] == "INDI":

        p=0

(Сначала делаем для мужчин, потом для женщин, чтобы при дальнейшем выводе это соответствовало нашему факту, где отец стоит на втором месте, а мать на третьем)

Далее пробегаемся по списку списков и ищем совпадения между FAMS и FAMC

        if (B[i][3] == B[j][1] and B[j][1]!=0):

            print(",",B[j][0],end = '', file = output)

        if (B[i][3] == B[j][2] and B[j][2]!=0):

            print(",",B[j][0],end = '', file = output)

## Предикат поиска родственника

Необходимо реализовать предикат поиска Шурина – брата жены. Для его нахождения я брал всех девушек, которые являются женами, т.е. стоят на 3-ем месте в предикате parents(потомок, отец, мать), из этого был получен предикат married(Y). Потом был реализован предикат поиска брата, где у разных потомков одинаковые родители, причем если родитель=father_NAN/mother_NAN, то данный человек находится на вершине нашего дерева и не подходит. Для определения брата нам нужен был еще пол человека, была идея посмотреть есть ли этот человек на месте отца в предикате parents(потомок, отец, мать). Но для этого нужно было, чтоб у него были дети. В связи с этим был сделан дополнительный предикат для определения пола - sex. Для определения Шурина достаточно было двух предикатов married и brother.

Исходный код (без фактов parents и sex):

brother(X,Y) :- 

parents(X,A,B), parents(Y,A,B), X\=Y, A\=father_NAN, B\=mother_NAN, sex(X,m).

married(Y) :- parents(_,_,Y).

shurin(X,Y) :- brother(X,Y), married(Y).

Пример запроса и вывода:

Запрос:

shurin(X,Y).

Вывод:

X = mikhail_kikimov,
Y = natalya_kikimova

X = mikhail_kikimov,
Y = natalya_kikimova

X = bosya,
Y = natalya_kikimova

X = bosya,
Y = natalya_kikimova

false

## Определение степени родства

Предикат relative вторым и третим аргументами принимает двух членов семьи, первый предикат определяет их взаимоотношение. Первым аргументом может быть мать, отец, сын, дочь, жена, муж, брат, сестра.

relative(son,Son,Parent) :- son(Son,Parent). ...

Запрос:

?-relative(son, X, alexander_pleshkov)

Результат:

X = oleg_pleshkov

Если мы хотим определить дальнейшую связь то для первого и второго аргументов должен быть определён relative Пример запроса: relative(X, alexey_pleshkov, alexandra_pleshkova)

Вывод: X = brother X = [son-father]

## Выводы

Данная курсовая работа была очень полезна для освоения. Сохранение дерева семьи в интернет ресурсе, где все родные люди могут его дополнять, позволит расширять его и не нужно будет хранить тонны бумаг, которые могут потеряться.

Язык Prolog удобен для переборов вариантов. Его использование в паре с другими языками программирования поможет рационально и эффективно написать код.
