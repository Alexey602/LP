**Отчет по лабораторной работе №1**
Поправьте отчет в формате md (восстановите таблицы для отметок), более подробно предикаты и запросы в п. Реляционное представление данных
Работа со списками и реляционным представлением данных

по курсу "Логическое программирование"

студент: Плешков A.О.

Результат проверки

  **Преподаватель**   **Дата**   **Оценка**
  ------------------- ---------- ------------
  Сошников Д.В.                  
  Левинская М.А.                 

**\
**

Введение
========

Язык Prolog(декларативный) отличается от императивных языков тем, что в
нем описывается КАКОЙ ИМЕННО результат мы хотим получить, и программа
ищет все подходящие факты. В императивных языках требуется описывать КАК
мы хотим получить результат.

Списки в Prolog похожи на связные списки в традиционных языках. Такие же
быстрые действия за О(1), как удаление/добавления элемента в начало
односвязного списка и долгое действие в виде доступа к n-ному элементу
за О(n). Единственное у нас нет явных указателей, но сама структура
практически идентична. Списки обычно разделяются на голову(первый
элемент) и хвост(остальные элементы).

Задание 1.1: Предикат обработки списка
======================================

/\*Удаление трех последних элементов\*/

delete(\[\_,\_,\_\],\[\]).

delete(\[X|Y\], \[X|Z\]) :- delete(Y,Z).

Пример использования:

delete(\[a,b,c,d,e,f\],X).

**X** = \[a, b, c\]

**false**

Т.к. требуется удалить последние 3 элемента списка, то подразумевается,
что список состоит из 3 и более элементов. Реализован рекурсивный
предикат, конец рекурсии – когда в списке 3 элемента. Первый аргумент –
начальный список, второй – конечный. Делаем рекурсию для хвостов
начального и конечного списков, отделяя голову.

Через стандартные предикаты:

remove\_3(L, X) :- append(X,A,L), lenght(A,3).

Задание 1.2: Предикат обработки числового списка
================================================

/\*Проверка упорядоченности элементов по возрастанию\*/

sequence(\[\_\]).

sequence(\[X,Y|Z\]) :- X&lt;Y, sequence(\[Y|Z\]).

Пример использования:

sequence(\[1,2,3,4\]).

**true**

**false**

На вход рекурсивному предикату подается список. Конец рекурсии – 1
элемент в списке. Делаем проверку на соблюдения условия 1-ый элемент
списка &lt; 2-ого и вызываем рекурсию для списка без 1-ого элемента.

Через стандартные предикаты:

sequence1(\[X,Y|Z\]) :- not(lenght(Z,0)), X&lt;Y, sequence(\[Y|Z\]).

Задание 2: Реляционное представление данных
===========================================

Реляционное представление данных обычно очень громоздкое, что путает
читателя, но программа, вычисляющая какие-то значения по таблице
позволяет сэкономить время, тк подсчеты для определенной задачи
одинаковы.

Для нахождения среднего балла по определенному предмету необходим список
баллов (обеспечивает предикат findall), подсчет длины(количества) нашего
списка (обеспечивает length), и сумма всех элементов списка
(обеспечивает sum), далее выводим средний балл(сумма/количество).

?- findall(X,grade(\_,\_,'Логическое программирование',X),C), lenght(C,N), sum(C,S), write(S/N),nl.

Для нахождения всех не сдавших экзамен из определенной группы считаем
длину списка, состоящего из ‘2’.

?- findall(2,grade(101,\_,\_,2),C), lenght(C,N), write(N),nl.

Для нахождения всех не сдавших экзамен по определенному предмету считаем
длину списка, состоящего из ‘2’.

?- findall(2,grade(\_,\_,'Логическое программирование',2),C), lenght(C,N), write(N),nl.

Вывод
=====

Благодаря встроенным предикатам findall(X,f(X),C)=bagoff, setoff работа
с таблицами осуществляется легче, чем это было бы в традиционных языках,
где приходится пробегаться по строкам и делать дополнительное условие на
совпадение каких-либо элементов, в связи с этим возрастает скорость
обработки. Сам код программы гораздо компактнее, что удобней. Также
встроенный предикат write помогает отладить программу в сомнительных
местах. А такие стандартные предикаты, как Length, member, remove,
append скорее всего еще не раз пригодятся в решении сложных задач,
поэтому их освоение было полезным.
